<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Roll & Score</title>

<!-- Link zum Web App Manifest -->
<link rel="manifest" href="manifest.json">

<!-- Optional: Theme Color für Browser UI -->
<meta name="theme-color" content="#0B57D0"> <!-- Passend zur Primary Color -->

<style>
  /* --- Material Design 3 Theme (Light Mode, Blue Accent) --- */
  :root {
    /* ... (CSS Variablen unverändert) ... */
     --md-sys-color-primary: #0B57D0; /* Hauptakzentfarbe (Blau) */
    --md-sys-color-on-primary: #FFFFFF; /* Text/Icons auf Primary */
    --md-sys-color-primary-container: #D8E2FF; /* Hellerer Hintergrund für hervorgehobene Elemente */
    --md-sys-color-on-primary-container: #001A41; /* Text/Icons auf Primary Container */
    --md-sys-color-secondary: #565E71; /* Sekundärfarbe (optional, hier weniger genutzt) */
    --md-sys-color-on-secondary: #FFFFFF;
    --md-sys-color-secondary-container: #DAE2F9;
    --md-sys-color-on-secondary-container: #131C2C;
    --md-sys-color-tertiary: #715573; /* Tertiärfarbe (optional) */
    --md-sys-color-on-tertiary: #FFFFFF;
    --md-sys-color-tertiary-container: #FBD7FC;
    --md-sys-color-on-tertiary-container: #29132D;
    --md-sys-color-error: #B3261E; /* Fehlerfarbe */
    --md-sys-color-on-error: #FFFFFF;
    --md-sys-color-error-container: #F9DEDC;
    --md-sys-color-on-error-container: #410E0B;
    --md-sys-color-background: #FEFBFF; /* Seitenhintergrund */
    --md-sys-color-on-background: #1B1B1F; /* Text auf Hintergrund */
    --md-sys-color-surface: #FEFBFF; /* Komponenten-Hintergrund (Karte, Tabelle) */
    --md-sys-color-on-surface: #1B1B1F; /* Text auf Surface */
    --md-sys-color-surface-variant: #E1E2EC; /* Leicht anderer Hintergrund (z.B. Th, calculated) */
    --md-sys-color-on-surface-variant: #44474F; /* Text auf Surface Variant */
    --md-sys-color-outline: #74777F; /* Ränder, Linien */
    --md-sys-color-shadow: #000000; /* Schattenfarbe */
    --md-sys-color-surface-container-highest: #E3E2E6; /* Für "erhöhte" Oberflächen wie Würfel */

    /* RGB Versionen für rgba() */
    --md-sys-color-primary-rgb: 11, 87, 208;
    --md-sys-color-on-surface-rgb: 27, 27, 31;
    --md-sys-color-shadow-rgb: 0, 0, 0;

    /* M3 Shape Tokens (Eckenradien) */
    --md-sys-shape-corner-none: 0px;
    --md-sys-shape-corner-extra-small: 4px;
    --md-sys-shape-corner-small: 8px;
    --md-sys-shape-corner-medium: 12px;
    --md-sys-shape-corner-large: 16px;
    --md-sys-shape-corner-extra-large: 28px;
    --md-sys-shape-corner-full: 999px; /* Für Pillenform */

    /* M3 Typeface (Optional - Verwende System-Schriftarten oder lade Roboto) */
    --md-sys-typescale-font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Behalte vorhandene */

    /* M3 Elevation (Schatten - vereinfacht) */
    --md-sys-elevation-level0: none;
    --md-sys-elevation-level1: 0px 1px 3px 1px rgba(var(--md-sys-color-shadow-rgb), 0.15), 0px 1px 2px 0px rgba(var(--md-sys-color-shadow-rgb), 0.3);
    --md-sys-elevation-level2: 0px 2px 6px 2px rgba(var(--md-sys-color-shadow-rgb), 0.15), 0px 1px 2px 0px rgba(var(--md-sys-color-shadow-rgb), 0.3);
    --md-sys-elevation-level3: 0px 4px 8px 3px rgba(var(--md-sys-color-shadow-rgb), 0.15), 0px 1px 3px 0px rgba(var(--md-sys-color-shadow-rgb), 0.3);
  }

  /* Basis-Styling */
  body {
    font-family: var(--md-sys-typescale-font-family);
    background-color: var(--md-sys-color-background);
    color: var(--md-sys-color-on-background);
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
  }

  h1 {
    margin-top: 1.5rem;
    font-weight: 400;
    color: var(--md-sys-color-primary);
    text-shadow: none;
  }

  /* Setup-Bereich */
  #setup {
    background-color: var(--md-sys-color-surface);
    color: var(--md-sys-color-on-surface);
    border-radius: var(--md-sys-shape-corner-large);
    padding: 1.5rem;
    margin: 1rem;
    width: 90vw;
    max-width: 500px; /* Schmaler als das Spielbrett */
    box-shadow: var(--md-sys-elevation-level1);
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  #setup label {
      display: block; /* Labels über den Eingabefeldern */
      margin-bottom: 0.25rem;
      color: var(--md-sys-color-on-surface-variant);
      font-size: 0.9rem;
  }

  #setup input[type="number"],
  #setup input[type="text"] {
      width: 100%; /* Volle Breite innerhalb des Containers */
      padding: 0.75rem;
      border: 1px solid var(--md-sys-color-outline);
      border-radius: var(--md-sys-shape-corner-extra-small);
      background-color: var(--md-sys-color-surface);
      color: var(--md-sys-color-on-surface);
      box-sizing: border-box; /* Padding und Border in die Breite einrechnen */
      font-size: 1rem;
  }
   #setup input[type="number"]:focus,
   #setup input[type="text"]:focus {
       outline: 2px solid var(--md-sys-color-primary);
        border-color: var(--md-sys-color-primary);
   }

  #player-names-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem; /* Abstand zwischen den Namensfeldern */
  }
  #setup-error {
      color: var(--md-sys-color-error);
      min-height: 1.2rem;
      font-size: 0.9rem;
      text-align: center;
  }

  /* Haupt-Spielbereich als "Karte" */
  #game {
    /* ... (Styling für #game unverändert) ... */
    background-color: var(--md-sys-color-surface);
    color: var(--md-sys-color-on-surface);
    border-radius: var(--md-sys-shape-corner-large); /* 16px */
    padding: 1.5rem;
    margin: 1rem;
    width: 90vw;
    max-width: 700px; /* Etwas mehr Platz */
    box-shadow: var(--md-sys-elevation-level1); /* M3 Schatten */
    display: none; /* <<<< INITIAL VERSTECKT */
    flex-direction: column;
    gap: 1.5rem; /* Mehr Abstand */
  }

  /* Tabelle */
  table {
    /* ... (Styling für table, th, td unverändert) ... */
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1rem;
    border: 1px solid var(--md-sys-color-outline); /* Außenrand */
    border-radius: var(--md-sys-shape-corner-small); /* Leichte Abrundung außen */
    overflow: hidden; /* Damit Radius auf Zellen wirkt */
  }

  th, td {
    border: none; /* M3 Tabellen oft ohne interne Linien */
    border-bottom: 1px solid var(--md-sys-color-outline); /* Horizontale Trennlinien */
    padding: 0.75rem; /* Mehr Padding */
    text-align: center;
    background-color: transparent; /* Standardmäßig transparent */
    color: var(--md-sys-color-on-surface);
    transition: background-color 0.2s ease;
    vertical-align: middle;
  }
  /* Letzte Zeile ohne Border unten */
   tbody tr:last-child td {
       border-bottom: none;
   }

  th {
    background-color: rgba(var(--md-sys-color-on-surface-rgb), 0.05); /* Sehr leichter Hintergrund */
    color: var(--md-sys-color-on-surface-variant); /* Gedämpfte Farbe für Header */
    font-weight: 500; /* Mittlere Dicke */
    text-align: left; /* Header linksbündig */
    border-bottom-width: 1px; /* Dickere Linie unter Header */
  }
   th:not(:first-child) { /* Score-Header zentriert */
       text-align: center;
   }

  td.category-name {
    text-align: left;
    font-weight: 400; /* Normale Dicke */
  }

  td.score-cell {
     font-weight: 500; /* Leicht fett */
     text-align: center;
  }

  /* Benutzte Zellen */
  td.used {
    background-color: rgba(var(--md-sys-color-on-surface-rgb), 0.08) !important; /* Leicht grau, !important beibehalten wg. JS */
    color: var(--md-sys-color-on-surface-variant); /* Gedämpfte Farbe */
    cursor: default !important;
  }

  /* Hover-Effekt für klickbare Zellen */
  td.score-cell:not(.used):not(.calculated):hover {
      /* Leichter blauer Hintergrund beim Hovern */
      background-color: rgba(var(--md-sys-color-primary-rgb), 0.08);
      cursor: pointer;
  }

  /* Berechnete Zellen (Summen, Bonus, Gesamt) */
  td.calculated {
      font-weight: 500; /* Mittlere Dicke */
      color: var(--md-sys-color-on-surface-variant); /* Leicht gedämpft */
      background-color: rgba(var(--md-sys-color-on-surface-rgb), 0.04); /* Sehr subtiler Hintergrund */
  }

  /* Würfel-Container */
  #dice-container {
    /* ... (Styling unverändert) ... */
    display: flex;
    justify-content: center;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    gap: 12px; /* Mehr Abstand */
  }

  /* Würfel-Styling */
  .dice {
    /* ... (Styling unverändert) ... */
    width: 55px; /* Etwas größer */
    height: 55px;
    background-color: var(--md-sys-color-surface-container-highest); /* Leicht erhöhter Hintergrund */
    border-radius: var(--md-sys-shape-corner-medium); /* 12px */
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2rem; /* Größer */
    font-weight: 500;
    color: var(--md-sys-color-on-surface);
    cursor: pointer;
    user-select: none;
    box-shadow: var(--md-sys-elevation-level1); /* Leichter Schatten */
    transition: transform 0.2s ease, background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
  }

  /* Gehaltene Würfel */
  .dice.held {
    /* ... (Styling unverändert) ... */
    background-color: var(--md-sys-color-primary-container); /* Heller Blauton */
    color: var(--md-sys-color-on-primary-container); /* Dunklerer Text darauf */
    transform: scale(1.05); /* Leichte Skalierung statt Anhebung */
    box-shadow: var(--md-sys-elevation-level2); /* Etwas mehr Schatten */
  }

  /* Steuerungs- und Speicher/Laden-Bereiche */
  .controls-section, .save-load-section {
      /* ... (Styling unverändert) ... */
      background: transparent; /* Kein extra Hintergrund */
      padding: 0; /* Kein extra Padding hier */
      border-radius: none;
      display: flex;
      flex-wrap: wrap;
      justify-content: center; /* Zentriert Buttons etc. */
      gap: 0.75rem; /* Abstand zwischen Elementen */
      align-items: center;
  }

  /* Buttons (M3 Filled Button Stil) */
  button {
    /* ... (Styling unverändert) ... */
    background-color: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
    border: none;
    padding: 0.75rem 1.5rem; /* M3 Padding */
    border-radius: var(--md-sys-shape-corner-full); /* Pillenform */
    font-size: 0.9rem; /* M3 Button Textgröße */
    font-weight: 500; /* Mittlere Dicke */
    text-transform: none; /* Keine Großbuchstaben */
    cursor: pointer;
    box-shadow: var(--md-sys-elevation-level1); /* Leichter Schatten */
    transition: background-color 0.2s ease, box-shadow 0.2s ease;
    outline: none; /* Standard-Outline entfernen */
  }

  /* Hover-Zustand für Buttons */
  button:hover:not(:disabled) {
    /* ... (Styling unverändert) ... */
    background-color: color-mix(in srgb, var(--md-sys-color-primary) 92%, var(--md-sys-color-on-primary) 8%);
    box-shadow: var(--md-sys-elevation-level2); /* Etwas mehr Schatten */
  }

   /* Aktiv-Zustand für Buttons */
   button:active:not(:disabled) {
      /* ... (Styling unverändert) ... */
      background-color: color-mix(in srgb, var(--md-sys-color-primary) 88%, var(--md-sys-color-on-primary) 12%);
      box-shadow: var(--md-sys-elevation-level1); /* Schatten wie normal */
   }

   /* Deaktivierte Buttons */
  button:disabled {
    /* ... (Styling unverändert) ... */
    background-color: rgba(var(--md-sys-color-on-surface-rgb), 0.12); /* Standard M3 Disabled BG */
    color: rgba(var(--md-sys-color-on-surface-rgb), 0.38); /* Standard M3 Disabled Text */
    cursor: not-allowed;
    box-shadow: var(--md-sys-elevation-level0); /* Kein Schatten */
  }

  /* Nachrichtenbereich */
  #message {
    /* ... (Styling unverändert) ... */
    margin: 0.5rem 0;
    font-weight: 400; /* Normale Dicke */
    min-height: 1.5rem;
    text-align: center;
    color: var(--md-sys-color-on-surface-variant); /* Gedämpfte Farbe für Standardnachrichten */
  }
  .error-message { color: var(--md-sys-color-error); }

  /* Manueller Modus Container (Checkbox + Label) */
   #manual-mode-container {
       /* ... (Styling unverändert) ... */
       display: flex;
       align-items: center;
       gap: 0.5rem;
       padding: 0; /* Kein extra Padding/BG */
       margin: 0;
   }

   #manual-mode-container label {
       /* ... (Styling unverändert) ... */
       cursor: pointer;
       color: var(--md-sys-color-on-surface);
       margin-bottom: 0; /* Reset margin from #setup label style */
       font-size: 1rem; /* Reset font size */
   }
   /* Einfaches M3-Styling für Checkbox */
   #manual-mode-checkbox {
       /* ... (Styling unverändert) ... */
       cursor: pointer;
       accent-color: var(--md-sys-color-primary); /* Browser-Checkbox Akzentfarbe anpassen */
       width: 18px;
       height: 18px;
       box-sizing: content-box; /* Ensure width/height is correct */
   }

  /* Animation für Würfel wackeln (unverändert) */
  @keyframes shake {
    /* ... (Unverändert) ... */
    0%, 100% { transform: translateX(0) rotate(0deg); }
    20% { transform: translateX(-4px) rotate(-5deg); }
    40% { transform: translateX(4px) rotate(5deg); }
    60% { transform: translateX(-4px) rotate(-5deg); }
    80% { transform: translateX(4px) rotate(5deg); }
  }
  .shaking {
    animation: shake 0.4s ease-in-out;
  }

  /* Style für Select Dropdown (unverändert) */
  select {
      /* ... (Styling unverändert) ... */
      padding: 0.6rem 1rem;
      border-radius: var(--md-sys-shape-corner-extra-small); /* 4px */
      border: 1px solid var(--md-sys-color-outline);
      background-color: var(--md-sys-color-surface);
      color: var(--md-sys-color-on-surface);
      font-family: inherit;
      font-size: 0.9rem;
      cursor: pointer;
      appearance: none; /* Entfernt Standard-Pfeil */
       /* Einfacher Pfeil als Hintergrundbild */
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='24' viewBox='0 -960 960 960' width='24' fill='%23${'74777F'.substring(1)}'%3E%3Cpath d='M480-345 240-585l43-43 197 198 197-198 43 43-240 240Z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      background-size: 1.5rem; /* Größe des Pfeils */
      padding-right: 3rem; /* Platz für den Pfeil */
  }
  select:disabled {
      /* ... (Styling unverändert) ... */
      background-color: rgba(var(--md-sys-color-on-surface-rgb), 0.12);
      color: rgba(var(--md-sys-color-on-surface-rgb), 0.38);
      border-color: rgba(var(--md-sys-color-on-surface-rgb), 0.12);
      cursor: not-allowed;
  }
  /* Label für Select */
  .save-load-section label {
      /* ... (Styling unverändert) ... */
      color: var(--md-sys-color-on-surface-variant);
  }

</style>
</head>
<body>

<h1>Roll & Score</h1>

<!-- NEU: Setup-Bereich -->
<div id="setup">
    <h2>Spiel einrichten</h2>
    <div>
        <label for="player-count">Anzahl Spieler (1-6):</label>
        <input type="number" id="player-count" min="1" max="6" value="2">
    </div>
    <div id="player-names-container">
        <!-- Namenfelder werden hier dynamisch eingefügt -->
    </div>
    <div id="setup-error"></div>
    <button id="start-game-btn">Spiel starten</button>
</div>

<!-- Bisheriger Spielbereich (jetzt initial versteckt) -->
<div id="game">
  <div id="dice-container">
    <!-- Würfel werden hier dynamisch generiert -->
  </div>
  <div class="controls-section">
    <button id="roll-btn">Würfeln</button>
    <button id="end-turn-btn" disabled>Zug beenden</button>
    <div id="manual-mode-container">
        <input type="checkbox" id="manual-mode-checkbox">
        <label for="manual-mode-checkbox">Manueller Modus</label>
    </div>
  </div>

  <div id="message"></div> <!-- Wird jetzt dynamisch befüllt -->

  <table id="scoreboard">
    <thead>
      <!-- Kopfzeile wird dynamisch generiert -->
    </thead>
    <tbody>
      <!-- Zeilen werden dynamisch generiert -->
    </tbody>
  </table>

  <div class="save-load-section">
    <button id="save-game-btn">Spiel speichern</button>
    <button id="new-game-btn">Neues Spiel</button>
    <label for="saved-games">Gespeicherte Spiele:</label>
    <select id="saved-games"></select>
    <button id="load-game-btn">Laden</button>
    <button id="delete-game-btn">Löschen</button>
    <!-- NEUER INSTALLATIONS-BUTTON (initial versteckt) -->
    <button id="install-pwa-btn" hidden>App installieren</button>
  </div>
</div>

<script>
  // ----- DOM Elemente -----
  const setupDiv = document.getElementById('setup');
  const gameDiv = document.getElementById('game');
  const playerCountInput = document.getElementById('player-count');
  const playerNamesContainer = document.getElementById('player-names-container');
  const startGameBtn = document.getElementById('start-game-btn');
  const setupError = document.getElementById('setup-error');

  const diceContainer = document.getElementById('dice-container');
  const rollBtn = document.getElementById('roll-btn');
  const endTurnBtn = document.getElementById('end-turn-btn');
  const saveGameBtn = document.getElementById('save-game-btn');
  const newGameBtn = document.getElementById('new-game-btn');
  const message = document.getElementById('message');
  const scoreboard = document.getElementById('scoreboard');
  const scoreboardHead = scoreboard.querySelector('thead');
  const scoreboardBody = scoreboard.querySelector('tbody');
  const savedGamesSelect = document.getElementById('saved-games');
  const loadGameBtn = document.getElementById('load-game-btn');
  const deleteGameBtn = document.getElementById('delete-game-btn');
  const manualModeCheckbox = document.getElementById('manual-mode-checkbox');
  const installButton = document.getElementById('install-pwa-btn'); // NEU: Installations-Button

  // ----- Spielkonstanten -----
  const categories = [
    'ones', 'twos', 'threes', 'fours', 'fives', 'sixes', // Upper section
    'threeOfKind', 'fourOfKind', 'fullHouse', 'smallStraight',
    'largeStraight', 'kniffel', 'chance' // Lower section
  ];
  const categoryNames = { // Für Anzeige und manuelle Eingabe
      'ones': 'Einser', 'twos': 'Zweier', 'threes': 'Dreier', 'fours': 'Vierer', 'fives': 'Fünfer', 'sixes': 'Sechser',
      'upperSum': 'Summe Oben', 'bonus': 'Bonus (ab 63 Pkt.)',
      'threeOfKind': 'Dreierpasch', 'fourOfKind': 'Viererpasch', 'fullHouse': 'Full House (25 Pkt.)',
      'smallStraight': 'Kleine Straße (30 Pkt.)', 'largeStraight': 'Große Straße (40 Pkt.)',
      'kniffel': 'Kniffel (50 Pkt.)', 'chance': 'Chance',
      'total': 'Gesamt'
   };
  const upperCategories = categories.slice(0, 6);
  const calculatedCategories = ['upperSum', 'bonus', 'total'];

  let gameState; // Wird erst nach Setup initialisiert
  const STORAGE_KEY = 'rollscoreSavedGames_v3'; // Key erhöht wg. möglicher Strukturänderung

  // ----- NEU: PWA Installations-Logik -----
  let deferredInstallPrompt = null; // Variable zum Speichern des Events

  window.addEventListener('beforeinstallprompt', (event) => {
    // Verhindere, dass der Browser die Mini-Infobar oder das Dialogfeld automatisch anzeigt
    event.preventDefault();
    // Speichere das Event, damit es später ausgelöst werden kann
    deferredInstallPrompt = event;
    // Zeige deinen benutzerdefinierten Installations-Button an
    installButton.hidden = false;
    console.log("PWA ist installierbar, 'beforeinstallprompt' gefeuert.");
  });

  installButton.addEventListener('click', async () => {
    console.log("Installations-Button geklickt.");
    if (!deferredInstallPrompt) {
      // Das Event ist nicht verfügbar (sollte nicht passieren, wenn der Button sichtbar ist)
      console.log("Kein Installations-Prompt verfügbar.");
      return;
    }
    // Zeige den Installations-Prompt des Browsers an
    deferredInstallPrompt.prompt(); // await ist hier nicht zwingend nötig, aber schadet nicht

    // Warte auf die Entscheidung des Benutzers
    const { outcome } = await deferredInstallPrompt.userChoice;
    console.log(`Benutzerentscheidung: ${outcome}`); // 'accepted' oder 'dismissed'

    // Das Prompt kann nur einmal verwendet werden. Setze es zurück.
    deferredInstallPrompt = null;
    // Verstecke den Button wieder, da der Prompt gezeigt wurde
    installButton.hidden = true;
  });

  window.addEventListener('appinstalled', () => {
    // Wird ausgelöst, nachdem die App erfolgreich installiert wurde
    console.log('PWA wurde installiert.');
    // Verstecke den Installationsbutton, falls er noch sichtbar ist
    installButton.hidden = true;
    deferredInstallPrompt = null; // Sicherstellen, dass das Prompt weg ist
  });

  // ----- Setup-Logik -----

  function generatePlayerNameInputs(count) {
    playerNamesContainer.innerHTML = ''; // Alte Felder löschen
    for (let i = 1; i <= count; i++) {
        const div = document.createElement('div');
        const label = document.createElement('label');
        label.htmlFor = `player-name-${i}`;
        label.textContent = `Name Spieler ${i}:`;
        const input = document.createElement('input');
        input.type = 'text';
        input.id = `player-name-${i}`;
        input.value = `Spieler ${i}`; // Standardwert
        input.required = true; // Einfache HTML5 Validierung
        div.appendChild(label);
        div.appendChild(input);
        playerNamesContainer.appendChild(div);
    }
  }

  playerCountInput.addEventListener('change', () => {
      const count = parseInt(playerCountInput.value);
      if (count >= 1 && count <= 6) {
          generatePlayerNameInputs(count);
          setupError.textContent = ''; // Fehler löschen
      } else {
          playerNamesContainer.innerHTML = ''; // Bei ungültiger Zahl Felder löschen
          setupError.textContent = 'Bitte eine Spieleranzahl zwischen 1 und 6 wählen.';
      }
  });

  startGameBtn.addEventListener('click', () => {
      const count = parseInt(playerCountInput.value);
      if (count < 1 || count > 6) {
          setupError.textContent = 'Ungültige Spieleranzahl.';
          return;
      }

      const nameInputs = playerNamesContainer.querySelectorAll('input[type="text"]');
      const playerNames = [];
      let namesValid = true;
      nameInputs.forEach((input, index) => {
          const name = input.value.trim();
          if (name === '') {
              namesValid = false;
          }
          playerNames.push(name || `Spieler ${index + 1}`); // Fallback falls leer
      });

      if (!namesValid) {
          setupError.textContent = 'Bitte geben Sie allen Spielern einen Namen.';
          return; // Abbruch, wenn ein Name leer ist
      }

      setupDiv.style.display = 'none'; // Setup ausblenden
      gameDiv.style.display = 'flex';  // Spiel anzeigen
      startGame(playerNames);         // Spiel initialisieren
  });

  // ----- Initialisierung des Spiels (nach Setup) -----

 function getDefaultGameState(playerNames) {
    const players = playerNames.map(name => ({
      name: name,
      scores: {},
      used: {}
    }));

    const state = {
      players: players,
      currentPlayer: 0,
      dice: [null, null, null, null, null],
      held: [false, false, false, false, false],
      rollsLeft: 3,
      turnPhase: 'roll',
      gameOver: false,
      timestamp: null,
      manualModeActive: false // Manuellen Modus initial aus
    };

    players.forEach(player => {
        categories.forEach(cat => {
            player.scores[cat] = null;
            player.used[cat] = false;
        });
    });
    return state;
 }

 function startGame(playerNames) {
    gameState = getDefaultGameState(playerNames);
    manualModeCheckbox.checked = gameState.manualModeActive; // Checkbox initial setzen
    rebuildScoreboardStructure(gameState.players); // Scoreboard Struktur aufbauen
    updateScoreboardUI();          // Scoreboard initial füllen (mit Nullen)
    createDiceUI();                // Würfel initial zeichnen ('?')
    setTurnPhase('roll');          // Erste Runde starten
    loadSavedGamesList();          // Liste laden (bleibt für Laden/Löschen relevant)
    saveGameBtn.disabled = false;  // Speichern-Button aktivieren
    console.log("Game started with players:", playerNames);
 }

  // ----- Scoreboard Struktur dynamisch aufbauen -----

 function rebuildScoreboardStructure(players) {
    scoreboardHead.innerHTML = ''; // Alten Header leeren
    scoreboardBody.innerHTML = ''; // Alten Body leeren

    // Kopfzeile erstellen
    const headerRow = scoreboardHead.insertRow();
    const thCategory = document.createElement('th');
    thCategory.textContent = 'Kategorie';
    headerRow.appendChild(thCategory);
    players.forEach(player => {
        const thPlayer = document.createElement('th');
        thPlayer.textContent = player.name;
        headerRow.appendChild(thPlayer);
    });

    // Body-Zeilen erstellen
    const allDisplayCategories = [
        ...categories.slice(0, 6), // Einser bis Sechser
        'upperSum', 'bonus',      // Summe Oben, Bonus
        ...categories.slice(6),   // Dreierpasch bis Chance
        'total'                   // Gesamt
    ];

    allDisplayCategories.forEach(catId => {
        const row = scoreboardBody.insertRow();
        row.dataset.category = catId; // Wichtig für Klick-Handler etc.

        const cellName = row.insertCell();
        cellName.textContent = categoryNames[catId];
        cellName.classList.add('category-name');

        players.forEach((player, playerIndex) => {
            const cellScore = row.insertCell();
            if (calculatedCategories.includes(catId)) {
                cellScore.classList.add('calculated');
                cellScore.textContent = '0'; // Initialwert für berechnete Felder
            } else {
                cellScore.classList.add('score-cell');
                // Listener wird später in updateScoreboardClickability hinzugefügt
            }
        });
    });
 }


  // ----- Würfel UI (unverändert) -----
  function createDiceUI() {
    diceContainer.innerHTML = '';
    for (let i = 0; i < 5; i++) {
      const die = document.createElement('div');
      die.classList.add('dice');
      if (gameState.held[i]) {
        die.classList.add('held');
      }
      die.textContent = gameState.dice[i] !== null ? gameState.dice[i] : '?';
      die.dataset.index = i;
      die.addEventListener('click', handleDieClick);
      diceContainer.appendChild(die);
    }
  }

  function handleDieClick(event) {
    if (gameState && gameState.rollsLeft < 3 && gameState.dice[0] !== null && gameState.turnPhase === 'roll' && !gameState.gameOver) {
      const index = parseInt(event.target.dataset.index);
      gameState.held[index] = !gameState.held[index];
      event.target.classList.toggle('held');
    }
  }

  function animateDice() {
    const diceElements = diceContainer.querySelectorAll('.dice:not(.held)');
    diceElements.forEach(die => {
      const delay = Math.random() * 100;
      setTimeout(() => {
          die.classList.add('shaking');
          setTimeout(() => die.classList.remove('shaking'), 400);
      }, delay);
    });
  }

  // ----- Spiellogik (weitgehend unverändert, nutzt gameState.players.length) -----
  function rollDice() {
    if (!gameState || gameState.rollsLeft <= 0 || gameState.turnPhase !== 'roll' || gameState.gameOver) {
      return;
    }

    gameState.rollsLeft--;
    let diceRolled = false;
    for (let i = 0; i < 5; i++) {
      if (!gameState.held[i]) {
        gameState.dice[i] = Math.floor(Math.random() * 6) + 1;
        diceRolled = true;
      }
    }

    if (diceRolled) {
      createDiceUI();
      animateDice();
    } else if (gameState.rollsLeft > 0) {
        message.textContent = `Bitte halte Würfel oder wähle eine Kategorie.`;
        return;
    }

    // Nachricht erst nach Animation/UI Update
    message.textContent = `${gameState.players[gameState.currentPlayer].name}: Würfe übrig: ${gameState.rollsLeft}.`;


    if (gameState.rollsLeft === 0) {
      rollBtn.disabled = true;
      message.textContent += ' Wähle eine Kategorie.';
      setTurnPhase('selectCategory');
    } else {
      rollBtn.disabled = false;
      endTurnBtn.disabled = false;
    }
  }

  function setTurnPhase(phase) {
      if (!gameState) return; // Sicherstellen, dass gameState existiert

      gameState.turnPhase = phase;
      rollBtn.disabled = true;
      endTurnBtn.disabled = true;
      manualModeCheckbox.disabled = true;
      message.classList.remove('error-message'); // Fehlerklasse sicherheitshalber entfernen

      if (gameState.gameOver) {
          phase = 'gameOver';
      }

      const currentPlayerName = gameState.players[gameState.currentPlayer]?.name || 'Spieler'; // Fallback

      switch(phase) {
          case 'roll':
              rollBtn.disabled = false;
              endTurnBtn.disabled = (gameState.rollsLeft === 3);
              manualModeCheckbox.disabled = false;
              updateScoreboardClickability(false);
              if (gameState.rollsLeft === 3) {
                 message.textContent = `${currentPlayerName} ist am Zug. Bitte würfeln.`;
              } else {
                 // Nachricht wurde in rollDice() gesetzt oder bleibt vom Laden
                 message.textContent = `${currentPlayerName}: Würfe übrig: ${gameState.rollsLeft}.`;
              }
              break;
          case 'selectCategory':
              manualModeCheckbox.disabled = false;
              message.textContent = `${currentPlayerName}: Wähle eine Kategorie${manualModeCheckbox.checked ? ' oder gib Punkte manuell ein' : ''}.`;
              updateScoreboardClickability(true);
              break;
          case 'gameOver':
              message.textContent = determineWinner();
              updateScoreboardClickability(false);
              saveGameBtn.disabled = true;
              break;
          default:
              console.error("Unbekannte Spielphase:", phase);
      }
  }

  // ----- Punkteberechnung (unverändert) -----
  function calculateScore(category, dice) {
    // ... (Logik unverändert) ...
    if (dice.some(d => d === null)) return 0;

    const counts = {};
    let sum = 0;
    dice.forEach(d => {
      counts[d] = (counts[d] || 0) + 1;
      sum += d;
    });
    const sortedDice = [...dice].sort();

    switch (category) {
      case 'ones': return (counts[1] || 0) * 1;
      case 'twos': return (counts[2] || 0) * 2;
      case 'threes': return (counts[3] || 0) * 3;
      case 'fours': return (counts[4] || 0) * 4;
      case 'fives': return (counts[5] || 0) * 5;
      case 'sixes': return (counts[6] || 0) * 6;
      case 'threeOfKind':
        return Object.values(counts).some(c => c >= 3) ? sum : 0;
      case 'fourOfKind':
        return Object.values(counts).some(c => c >= 4) ? sum : 0;
      case 'fullHouse':
        return (Object.values(counts).includes(3) && Object.values(counts).includes(2)) ? 25 : 0;
      case 'smallStraight': {
        const uniqueSortedStr = [...new Set(sortedDice)].sort((a, b) => a - b).join('');
        return /(1234|2345|3456)/.test(uniqueSortedStr) ? 30 : 0;
      }
      case 'largeStraight': {
        const uniqueSortedStr = [...new Set(sortedDice)].sort((a, b) => a - b).join('');
        return /(12345|23456)/.test(uniqueSortedStr) ? 40 : 0;
      }
      case 'kniffel':
        return Object.values(counts).some(c => c >= 5) ? 50 : 0;
      case 'chance':
        return sum;
      default: return 0;
    }
  }

  // ----- Scoreboard UI Update (fültt jetzt die dynamisch erstellte Struktur) -----
  function updateScoreboardUI() {
    if (!gameState) return; // Nicht updaten, wenn noch kein Spiel läuft

    gameState.players.forEach((player, playerIndex) => {
      let upperSum = 0;
      let totalSum = 0;

      // Update individual category scores
      categories.forEach(category => {
        const cell = scoreboardBody.querySelector(`tr[data-category="${category}"] td:nth-child(${playerIndex + 2})`); // +2 wegen Kategorie-Spalte
        if (cell) {
          const score = player.scores[category];
          cell.textContent = score !== null ? score : '';
          if (player.used[category]) {
              cell.classList.add('used');
          } else {
              cell.classList.remove('used');
          }
        }
        // Calculate sums
        if (player.scores[category] !== null) {
          if (upperCategories.includes(category)) {
            upperSum += player.scores[category];
          }
           totalSum += player.scores[category];
        }
      });

      // Update Upper Sum
      const upperSumCell = scoreboardBody.querySelector(`tr[data-category="upperSum"] td:nth-child(${playerIndex + 2})`);
      if (upperSumCell) upperSumCell.textContent = upperSum;

      // Update Bonus
      const bonusCell = scoreboardBody.querySelector(`tr[data-category="bonus"] td:nth-child(${playerIndex + 2})`);
      const bonus = upperSum >= 63 ? 35 : 0;
      if (bonusCell) bonusCell.textContent = bonus;
      totalSum += bonus;

      // Update Total Sum
      const totalCell = scoreboardBody.querySelector(`tr[data-category="total"] td:nth-child(${playerIndex + 2})`);
      if (totalCell) totalCell.textContent = totalSum;
    });
  }

 function updateScoreboardClickability(enable) {
     if (!gameState) return;
     const playerIndex = gameState.currentPlayer;
     categories.forEach(category => {
         const row = scoreboardBody.querySelector(`tr[data-category="${category}"]`);
         if (!row) return;
         // +2, da erste Spalte Kategorie, zweite Spalte Spieler 0 (Index 0 -> nth-child(2)) etc.
         const cell = row.querySelectorAll('td')[playerIndex + 1]; //querySelectorAll gibt NodeList, Index ist 0-basiert

         if (!cell) return;

         cell.removeEventListener('click', handleCategoryClick); // Alten Listener entfernen

         if (enable && !gameState.players[playerIndex].used[category]) {
             cell.addEventListener('click', handleCategoryClick);
             cell.classList.remove('used'); // Sicherstellen, dass 'used' weg ist, falls vorher gesetzt
         } else {
             // Wenn nicht aktiviert oder bereits benutzt, sicherstellen, dass 'used' gesetzt ist (falls zutreffend)
             if (gameState.players[playerIndex].used[category]) {
                 cell.classList.add('used');
             } else {
                 cell.classList.remove('used'); // Zelle ist nicht benutzt und nicht klickbar (anderer Spieler dran)
             }
         }
     });
 }


 function handleCategoryClick(event) {
    const cell = event.target;
    const row = cell.closest('tr');
    const category = row.dataset.category;
    const playerIndex = gameState.currentPlayer;
    const isManualMode = manualModeCheckbox.checked;

    if (!gameState || gameState.turnPhase !== 'selectCategory' || gameState.players[playerIndex].used[category]) {
        return;
    }

    let score = 0;
    message.classList.remove('error-message'); // Evtl. alte Fehlermeldung entfernen

    if (isManualMode) {
        const categoryDisplayName = categoryNames[category] || category; // Angezeigten Namen holen
        const manualScoreInput = prompt(`${gameState.players[playerIndex].name}: Punktzahl für "${categoryDisplayName}"?`, "0");

        if (manualScoreInput === null) {
            message.textContent = "Manuelle Eingabe abgebrochen.";
            return;
        }
        const manualScore = parseInt(manualScoreInput);
        if (isNaN(manualScore) || manualScore < 0) {
            message.textContent = "Ungültige Eingabe. Bitte eine nicht-negative Zahl eingeben.";
            message.classList.add('error-message');
            return;
        }
        score = manualScore;
        message.textContent = `Manuell ${score} Punkte für ${categoryDisplayName} eingetragen.`;
    } else {
        if (gameState.dice.some(d => d === null)) {
            message.textContent = "Bitte zuerst würfeln!";
            message.classList.add('error-message');
            return;
        }
        score = calculateScore(category, gameState.dice);
        const categoryDisplayName = categoryNames[category] || category;
        message.textContent = `${score} Punkte für ${categoryDisplayName}.`;
    }

    gameState.players[playerIndex].scores[category] = score;
    gameState.players[playerIndex].used[category] = true;
    cell.classList.add('used'); // Zelle sofort als benutzt markieren

    console.log(`Player ${playerIndex+1} (${gameState.players[playerIndex].name}) selected ${category}, score: ${score}, manual: ${isManualMode}`);

    updateScoreboardUI(); // Summen etc. neu berechnen
    updateScoreboardClickability(false); // Alle Zellen nicht mehr klickbar machen für diesen Zug
    nextTurn();
 }

   // ----- Spielablauf (angepasst für gameState.players.length) -----
   function endTurn() {
    if (!gameState || gameState.turnPhase === 'roll' && gameState.rollsLeft < 3 && !gameState.gameOver) {
       if (gameState.dice.some(d => d === null)) {
           message.textContent = "Bitte zuerst würfeln, bevor der Zug beendet wird.";
           message.classList.add('error-message');
           return;
       }
       setTurnPhase('selectCategory');
    }
  }

 function nextTurn() {
    if (!gameState || checkGameOver()) { // Check auf gameState hinzugefügt
        return;
    }

    gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.players.length; // Nächster Spieler basierend auf Array-Länge
    gameState.rollsLeft = 3;
    gameState.held = [false, false, false, false, false];
    gameState.dice = [null, null, null, null, null];
    // Manueller Modus bleibt erhalten (gameState.manualModeActive wird nicht zurückgesetzt)

    setTurnPhase('roll');
    createDiceUI();
    updateScoreboardUI(); // Nur um sicherzugehen (sollte sich nichts ändern)

    console.log("Next turn. Player:", gameState.currentPlayer + 1, `(${gameState.players[gameState.currentPlayer]?.name || 'Unbekannt'})`);
}


 function checkGameOver() {
    if (!gameState) return false; // Kann nicht vorbei sein, wenn kein Spiel läuft

    const isOver = gameState.players.every(player =>
        categories.every(cat => player.used[cat])
    );

    if (isOver) {
      gameState.gameOver = true;
      setTurnPhase('gameOver');
      return true;
    }
    return false;
 }

 function determineWinner() {
     if (!gameState || !gameState.gameOver) return "";

      const finalScores = gameState.players.map((p, index) => {
          const upperSum = upperCategories.reduce((sum, cat) => sum + (p.scores[cat] || 0), 0);
          const bonus = upperSum >= 63 ? 35 : 0;
          const total = categories.reduce((sum, cat) => sum + (p.scores[cat] || 0), 0) + bonus;
          return { name: p.name, score: total };
      });

      finalScores.sort((a, b) => b.score - a.score); // Höchste Punktzahl zuerst

      let winnerMsg = "Spiel beendet! Endstand:\n"; // \n für mögliche Zeilenumbrüche, falls viele Spieler
      finalScores.forEach((player, index) => {
           winnerMsg += `${index > 0 ? ', ' : ''}${player.name}: ${player.score}`;
      });

      // Gewinner ermitteln (können mehrere sein bei Gleichstand)
      const maxScore = finalScores[0].score;
      const winners = finalScores.filter(p => p.score === maxScore);

      if (winners.length === 1) {
          winnerMsg += `\n${winners[0].name} gewinnt!`;
      } else if (winners.length > 1 && winners.length < finalScores.length) {
          winnerMsg += `\nUnentschieden zwischen: ${winners.map(w => w.name).join(', ')}!`;
      } else { // Alle haben die gleiche Punktzahl (oder nur 1 Spieler)
           if (finalScores.length > 1) {
               winnerMsg += "\nUnentschieden!";
           } else {
               // Nur ein Spieler, kein "Gewinner" nötig
           }
      }
      return winnerMsg;
 }

  // ----- Spiel speichern/laden (angepasst für dynamisches Scoreboard) -----

  function saveGame() {
    if (!gameState || gameState.gameOver) {
        message.textContent = "Aktuelles oder abgeschlossenes Spiel kann nicht gespeichert werden.";
        return;
    }
    try {
        const savedGames = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        // Manuell-Modus Status mit speichern
        gameState.manualModeActive = manualModeCheckbox.checked;
        gameState.timestamp = new Date().toLocaleString('de-DE', { dateStyle: 'short', timeStyle: 'short' });

        savedGames.push(JSON.parse(JSON.stringify(gameState))); // Tiefe Kopie!

        localStorage.setItem(STORAGE_KEY, JSON.stringify(savedGames));
        loadSavedGamesList(); // Liste aktualisieren (neues Spiel ist jetzt oben)
        message.textContent = `Spiel gespeichert (${gameState.timestamp}).`;
        console.log("Game saved");
    } catch (e) {
        message.textContent = "Fehler beim Speichern des Spiels.";
        console.error("Save game error:", e);
    }
  }

  function loadSavedGamesList() {
    try {
        const savedGames = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        savedGamesSelect.innerHTML = '';
        if (savedGames.length === 0) {
            const option = document.createElement('option');
            option.textContent = "Keine Spiele";
            option.disabled = true;
            savedGamesSelect.appendChild(option);
            loadGameBtn.disabled = true;
            deleteGameBtn.disabled = true;
        } else {
            // Spiele in umgekehrter Reihenfolge (neueste zuerst) anzeigen
            savedGames.slice().reverse().forEach((game, reverseIndex) => {
              const originalIndex = savedGames.length - 1 - reverseIndex; // Korrekter Index im Originalarray
              const option = document.createElement('option');
              option.value = originalIndex; // Wert ist der Index im ursprünglichen Array
              // Zeige Spieleranzahl und Namen (falls vorhanden) im Dropdown
              let playerInfo = game.players ? `(${game.players.length} Spieler: ${game.players.map(p=>p.name).slice(0,2).join(', ')}${game.players.length > 2 ? '...' : ''})` : '(?)';
              option.textContent = game.timestamp ? `Spiel vom ${game.timestamp} ${playerInfo}` : `Spiel ${originalIndex + 1} ${playerInfo}`;
              savedGamesSelect.appendChild(option);
            });
            loadGameBtn.disabled = false;
            deleteGameBtn.disabled = false;
        }
    } catch (e) {
        message.textContent = "Fehler beim Laden der Liste gespeicherter Spiele.";
        console.error("Load list error:", e);
        localStorage.removeItem(STORAGE_KEY); // Potenzielle Fehlerquelle entfernen
        loadSavedGamesList();
    }
  }

 function loadGame() {
    try {
        const savedGames = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        const index = parseInt(savedGamesSelect.value);

        if (!isNaN(index) && index >= 0 && index < savedGames.length) {
            // Spiel laden
            gameState = JSON.parse(JSON.stringify(savedGames[index])); // Tiefe Kopie

            // UI vorbereiten
            setupDiv.style.display = 'none'; // Sicherstellen, dass Setup weg ist
            gameDiv.style.display = 'flex';   // Spiel anzeigen

            // --- WICHTIG: Scoreboard Struktur basierend auf geladenen Spielern neu aufbauen ---
            rebuildScoreboardStructure(gameState.players);

            // Restliche UI aktualisieren
            updateScoreboardUI(); // Jetzt die Werte eintragen
            createDiceUI();       // Würfel und gehaltenen Status zeigen
            manualModeCheckbox.checked = gameState.manualModeActive || false; // Checkbox Status

            // Korrekten Spielzustand wiederherstellen
            setTurnPhase(gameState.gameOver ? 'gameOver' : gameState.turnPhase);

            // Nachricht anpassen
            const loadTime = gameState.timestamp || `Index ${index}`;
            let currentStatusMsg = message.textContent; // Holen, was setTurnPhase gesetzt hat
            // Kombiniere Nachrichten, aber vermeide Dopplung der Spielerinfo falls vorhanden
            if (currentStatusMsg.includes("ist am Zug") || currentStatusMsg.includes("Wähle eine Kategorie")) {
                 message.textContent = `Spiel vom ${loadTime} geladen. ${currentStatusMsg}`;
            } else {
                 message.textContent = `Spiel vom ${loadTime} geladen.`; // Falls GameOver oder anderer Status
            }

            saveGameBtn.disabled = gameState.gameOver; // Kein Speichern bei Game Over

            console.log("Game loaded:", gameState);

        } else {
          message.textContent = 'Fehler: Ausgewähltes Spiel nicht gefunden.';
          console.error("Invalid index or no game data found for index:", index);
        }
    } catch (e) {
         message.textContent = "Fehler beim Laden des Spiels.";
         console.error("Load game error:", e);
         // Optional: Versuchen, die Liste neu zu laden, falls das Problem dort lag
         loadSavedGamesList();
    }
 }

 function deleteGame() {
    // ... (Logik unverändert, löscht basierend auf Index) ...
    try {
        const savedGames = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
        const index = parseInt(savedGamesSelect.value);

        if (!isNaN(index) && index >= 0 && index < savedGames.length) {
            const timestampToDelete = savedGames[index].timestamp || `Spiel ${index + 1}`;
            if (confirm(`Soll das Spiel "${timestampToDelete}" wirklich gelöscht werden?`)) {
                savedGames.splice(index, 1); // Spiel am ausgewählten Index entfernen
                localStorage.setItem(STORAGE_KEY, JSON.stringify(savedGames));
                loadSavedGamesList(); // Dropdown-Liste aktualisieren
                message.textContent = `Spiel (${timestampToDelete}) gelöscht.`;
                console.log("Game deleted at index:", index);
            }
        } else {
            message.textContent = 'Konnte Spiel nicht löschen (ungültiger Index).';
            console.error("Invalid index for deletion:", index);
        }
    } catch (e) {
        message.textContent = "Fehler beim Löschen des Spiels.";
        console.error("Delete game error:", e);
    }
 }

   // ----- Event Listeners -----
  rollBtn.addEventListener('click', rollDice);
  endTurnBtn.addEventListener('click', endTurn);
  saveGameBtn.addEventListener('click', saveGame);
  newGameBtn.addEventListener('click', () => {
    // Frage nur, wenn ein Spiel aktiv ist (gameDiv sichtbar ist)
    if (gameDiv.style.display === 'flex' && !confirm("Neues Spiel starten? Nicht gespeicherte Änderungen gehen verloren.")) {
        return; // Abbruch durch Benutzer
    }
    // Zurück zum Setup
    gameDiv.style.display = 'none';
    setupDiv.style.display = 'flex';
    gameState = null; // Aktuellen Spielzustand verwerfen
    // Felder im Setup zurücksetzen/neu generieren
    playerCountInput.value = 2; // Standardwert
    generatePlayerNameInputs(2); // Standardmäßig 2 Spieler anzeigen
    setupError.textContent = ''; // Fehler löschen
    // Gespeicherte Spiele Liste bleibt erhalten
  });
  loadGameBtn.addEventListener('click', loadGame);
  deleteGameBtn.addEventListener('click', () => {
      if (savedGamesSelect.selectedIndex >= 0 && savedGamesSelect.options.length > 0 && !savedGamesSelect.options[0].disabled) {
          // Bestätigungsdialog jetzt in deleteGame() integriert
          deleteGame();
      } else {
          message.textContent = "Bitte zuerst ein Spiel zum Löschen auswählen.";
      }
  });
  manualModeCheckbox.addEventListener('change', () => {
      if (gameState) { // Nur wenn ein Spiel läuft
          gameState.manualModeActive = manualModeCheckbox.checked; // Status im State speichern
           if (gameState.turnPhase === 'selectCategory') {
               const currentPlayerName = gameState.players[gameState.currentPlayer]?.name || 'Spieler';
               message.textContent = `${currentPlayerName}: Wähle eine Kategorie${manualModeCheckbox.checked ? ' oder gib Punkte manuell ein' : ''}.`;
           }
      }
  });

  // ----- NEU: Service Worker Registrierung -----
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js') // Pfad zur Service Worker Datei
        .then(registration => {
          console.log('ServiceWorker registration successful with scope: ', registration.scope);
        })
        .catch(error => {
          console.log('ServiceWorker registration failed: ', error);
        });
    });
  }


  // ----- Initialisierung der App -----
  function initializeApp() {
      // Initial Setup UI anzeigen
      setupDiv.style.display = 'flex';
      gameDiv.style.display = 'none';
      generatePlayerNameInputs(parseInt(playerCountInput.value)); // Initiale Namensfelder für Standard-Spielerzahl
      loadSavedGamesList(); // Liste gespeicherter Spiele laden (für Laden/Löschen Button im Spiel)
      console.log("App initialized, showing setup.");
      // Hinweis: PWA Install Prompt Listener sind bereits global registriert
      // Hinweis: Service Worker Registrierung erfolgt bei 'load'
  }

  initializeApp(); // App starten

</script>
</body>
</html>
